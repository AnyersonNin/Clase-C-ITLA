----------------------
 Asignación unidad 1
----------------------
API de Gestión de Tareas

Objetivo Principal

Crear una API funcional que permita:

- Realizar operaciones CRUD (crear, leer, actualizar y eliminar) sobre tareas.
- Implementar validaciones para garantizar datos consistentes.
- Manejar excepciones de manera estructurada.
- Utilizar programación asíncrona para mejorar el rendimiento.
-----------------
Funcionalidades
----------------
1. Operaciones CRUD
La API permite las siguientes acciones:

-Crear tareas: Proporcionando descripción, fecha de vencimiento y estado inicial.
- Consultar tareas: Obtener todas las tareas existentes o aplicar filtros por estado o fecha de vencimiento.
- Actualizar tareas: Modificar atributos como descripción, estado o fecha de vencimiento.
- Eliminar tareas: Eliminar tareas que ya no sean necesarias.
Al finalizar esta etapa:
1. La estructura del proyecto estará configurada según las mejores prácticas.
2. Los endpoints CRUD básicos estarán funcionales.
3. La conexión con la base de datos estará correctamente establecida.
4. Los datos de entrada estarán validados adecuadamente.
5. Las respuestas serán estructuradas y consistentes.
6. La API estará preparada para futuras expansiones.
--------------------------------------------------------------------------------
Desarrollo de la Etapa 2: Delegados, Funciones Anónimas y Uso de Action y Func
--------------------------------------------------------------------------------
Detalles de cambios:
Se han implementado el uso de delegados, funciones anónimas, Action, y Func, que incluyen:
1.	Delegado para validar tareas.
2.	Uso de Action para notificaciones.
3.	Func para cálculos derivados.
4.	Funciones anónimas para filtros.
Con estas modificaciones, la API se ha vuelto más flexible, reutilizable y sencilla de mantener. Ahora es capaz de validar, notificar y calcular de manera dinámica sin necesidad de alterar la lógica principal. Esto no solo optimiza la escalabilidad, sino que también facilita la integración de futuras funcionalidades.
-------------------------------------
Etapa 3: Patrones de Diseño en POO
-------------------------------------
1.	Flexibilidad y escalabilidad: La API será modular y adaptable a futuros cambios sin afectar su estructura.
2.	Mantenibilidad y organización: Mejor separación de responsabilidades, con un código más limpio y fácil de actualizar.
3.	Optimización y reutilización: Gestión eficiente de tareas con configuraciones específicas.
4.	Integración ágil: Nuevas funcionalidades podrán añadirse sin modificar el código existente.
Este enfoque mejora la eficiencia, reduce la complejidad y facilita la evolución de la API.
-------------------------------------------
Etapa 4: Programación Reactiva con Rx.NET
-------------------------------------------
1.	Ejecución secuencial: Las tareas se procesarán en orden, evitando solapamientos.
2.	Gestión eficiente: Uso de una cola FIFO para organizar la ejecución de tareas.
3.	Mayor estabilidad: Reducción de conflictos y mejora en la previsibilidad del sistema.
4.	Simplicidad y escalabilidad: Implementación sin depender de eventos en tiempo real.
Este enfoque optimiza el manejo de tareas, asegurando un procesamiento ordenado y eficiente.
-----------------------------------------------------------------------
Etapa 5: Optimización de funciones con memorización
-----------------------------------------------------------------------
1.	Mejora del rendimiento: Reducción del tiempo de respuesta mediante el almacenamiento en caché de resultados de funciones costosas.
2.	Evitar cálculos repetitivos: Al reutilizar los resultados almacenados en caché, se elimina la necesidad de realizar cálculos redundantes.
3.	Implementación de funciones puras: Uso de funciones que siempre devuelven el mismo resultado con las mismas entradas, facilitando su almacenamiento en caché.
4.	Escalabilidad optimizada: A medida que se añaden nuevas funciones, solo es necesario registrar sus resultados en la caché, sin afectar el rendimiento general.



